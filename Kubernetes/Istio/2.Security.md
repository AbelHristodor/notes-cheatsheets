---
created: 2024-03-10T11:58
updated: 2024-04-09T14:38
tags: 
category: 
---
<small> Note: these notes are all taken from the official <a href="https://istio.io/latest/docs/concepts/traffic-management/"> Istio documentation</a></small>

<hr>

# 2.Security
Security in Istio involves multiple components:
- A **Certificate Authority (CA)** for key and certificate management
- The configuration API server distributes to the proxies:
	- *authentication policies*
	- *authorization policies*
	- *secure naming information*
- Sidecar and perimeter proxies work as **Policy Enforcement Points (PEPs)** to secure communication between clients and servers.
- A set of Envoy proxy extensions to manage **telemetry and auditing**

![[IstioMersh.png]]
## [Istio identity](https://istio.io/latest/docs/concepts/security/#istio-identity)
Identity is a fundamental concept of any security infrastructure. At the beginning of a workload-to-workload communication, the two parties must **exchange credentials** with their identity information for **mutual authentication** purposes. On the client side, the server’s identity is checked against the [secure naming](https://istio.io/latest/docs/concepts/security/#secure-naming) information to see if it is an authorized runner of the workload. On the server side, the server can determine what information the client can access based on the [authorization policies](https://istio.io/latest/docs/concepts/security/#authorization-policies), audit who accessed what at what time, charge clients based on the workloads they used, and reject any clients who failed to pay their bill from accessing the workloads.

The Istio identity model uses the first-class `service identity` to determine the identity of a request’s origin. This model allows for **great flexibility** and granularity for service identities to represent a human user, an individual workload, or a group of workloads. 

The following list shows examples of service identities that you can use on different platforms:

- Kubernetes: Kubernetes service account
- GCE: GCP service account
- On-premises (non-Kubernetes): user account, custom service account, service name, Istio service account, or GCP service account. 
## [Identity and certificate management](https://istio.io/latest/docs/concepts/security/#pki)
Istio securely provisions strong identities to every workload with **X.509 certificates**. Istio agents, running alongside each Envoy proxy, work together with `istiod` to automate key and certificate rotation at scale. The following diagram shows the identity provisioning flow.

![[IstioCerts.png]]

Istio provisions keys and certificates through the following flow:
1. `istiod` offers a gRPC service to take **certificate signing requests (CSRs)**.
2. When started, the Istio agent creates the private key and CSR, and then sends the CSR with its credentials to `istiod` for signing.
3. The CA in istiod **validates** the credentials carried in the CSR. Upon successful validation, it signs the CSR to generate the certificate.
4. When a workload is started, Envoy requests the certificate and key from the Istio agent in the same container via the **Envoy secret discovery service (SDS)** API.
5. The Istio agent sends the certificates received from istiod and the private key to Envoy via the Envoy SDS API.
6. Istio agent monitors the expiration of the workload certificate. The above process repeats periodically for certificate and key rotation.

## Authentication
Istio provides two types of authentication:
- **Peer authentication**: used for *service-to-service authentication* to verify the client making the connection. Istio offers [mutual TLS](https://en.wikipedia.org/wiki/Mutual_authentication) as a full stack solution for transport authentication, which can be enabled without requiring service code changes. This solution:
    - Provides each service with a **strong identity** representing its role to enable interoperability across clusters and clouds.
    - **Secures** service-to-service **communication**.
    - Provides a **key management system** to automate key and certificate generation, distribution, and rotation.
- **Request authentication**: Used for end-user authentication to verify the credential attached to the request. Istio enables request-level authentication with JSON Web Token (JWT) validation and a streamlined developer experience using a custom authentication provider or any OpenID Connect providers, for example:
    - [ORY Hydra](https://www.ory.sh/)
    - [Keycloak](https://www.keycloak.org/)
    - [Auth0](https://auth0.com/)
    - [Firebase Auth](https://firebase.google.com/docs/auth/)
    - [Google Auth](https://developers.google.com/identity/protocols/OpenIDConnect)

In all cases, Istio stores the **authentication policies** in the `Istio config store` via a custom Kubernetes API. `Istiod` keeps them up-to-date for each proxy, along with the keys where appropriate. Additionally, Istio supports authentication in permissive mode to help you understand how a policy change can affect your security posture before it is enforced.

### [Mutual TLS authentication](https://istio.io/latest/docs/concepts/security/#mutual-tls-authentication)
Istio tunnels service-to-service communication through the client- and server-side *PEPs*, which are implemented as [Envoy proxies](https://www.envoyproxy.io/). When a workload sends a request to another workload using mutual TLS authentication, the request is handled as follows:

1. Istio re-routes the outbound traffic from a client to the *client’s local sidecar* Envoy.
2. The client side Envoy starts a **mutual TLS handshake** with the server side Envoy. During the handshake, the client side Envoy also does a [secure naming](https://istio.io/latest/docs/concepts/security/#secure-naming) check to verify that the service account presented in the server certificate is authorized to run the target service.
3. The client side Envoy and the server side Envoy establish a mutual TLS connection, and Istio forwards the traffic from the client side Envoy to the server side Envoy.
4. The server side Envoy authorizes the request. If authorized, it forwards the traffic to the backend service through local TCP connections.

Istio configures `TLSv1_2` as the minimum TLS version for both client and server with the following cipher suites:
- `ECDHE-ECDSA-AES256-GCM-SHA384`
- `ECDHE-RSA-AES256-GCM-SHA384`
- `ECDHE-ECDSA-AES128-GCM-SHA256`
- `ECDHE-RSA-AES128-GCM-SHA256`
- `AES256-GCM-SHA384`
- `AES128-GCM-SHA256`
#### [Permissive mode](https://istio.io/latest/docs/concepts/security/#permissive-mode)
Istio mutual TLS has a **permissive mode**, which allows a service to accept both **plaintext** traffic and **mutual TLS** traffic at the same time. This feature greatly improves the mutual TLS onboarding experience.

#### [Secure naming](https://istio.io/latest/docs/concepts/security/#secure-naming)
**Server identities** are encoded in **certificates**, but service names are retrieved through the **discovery service** or **DNS**. The secure naming information maps the server identities to the service names. A mapping of identity `A` to service name `B` means “`A` is authorized to run service `B`”. The control plane watches the `apiserver`, generates the secure naming mappings, and distributes them securely to the PEPs.


### [Authentication architecture](https://istio.io/latest/docs/concepts/security/#authentication-architecture)
You can specify authentication requirements for workloads receiving requests in an Istio mesh using **peer and request authentication policies**. The mesh operator uses `.yaml` files to specify the policies. The policies are saved in the Istio configuration storage once deployed. The Istio controller watches the configuration storage.

Upon any policy changes, the new policy is translated to the appropriate configuration telling the PEP how to perform the required authentication mechanisms. The control plane may fetch the public key and attach it to the configuration for JWT validation. Alternatively, Istiod provides the path to the keys and certificates the Istio system manages and installs them to the application pod for mutual TLS. You can find more info in the [Identity and certificate management section](https://istio.io/latest/docs/concepts/security/#pki).

Istio sends configurations to the targeted endpoints **asynchronously**. Once the proxy receives the configuration, the new authentication requirement takes effect immediately on that pod.

Client services, those that send requests, are responsible for following the necessary authentication mechanism. For request authentication, the application is responsible for acquiring and attaching the JWT credential to the request. For peer authentication, Istio automatically upgrades all traffic between two PEPs to mutual TLS. If authentication policies disable mutual TLS mode, Istio continues to use plain text between PEPs. To override this behavior explicitly disable mutual TLS mode with [destination rules](https://istio.io/latest/docs/concepts/traffic-management/#destination-rules). You can find out more about how mutual TLS works in the [Mutual TLS authentication section](https://istio.io/latest/docs/concepts/security/#mutual-tls-authentication).
![[IstioAuthArch.png]]

### [Authentication policies](https://istio.io/latest/docs/concepts/security/#authentication-policies)
This section provides more details about how Istio authentication policies work. Authentication policies apply to requests that a service receives. To specify client-side authentication rules in **mutual TLS**, you need to specify the `TLSSettings` in the `DestinationRule`. You can find more information in our [TLS settings reference docs](https://istio.io/latest/docs/reference/config/networking/destination-rule#ClientTLSSettings).

You deploy policies using `kubectl`. The following example authentication policy specifies that transport authentication for the workloads with the `app:reviews` label must use mutual TLS:

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: "example-peer-policy"
  namespace: "foo"
spec:
  selector:
    matchLabels:
      app: reviews
  mtls:
    mode: STRICT
```

#### [Policy storage](https://istio.io/latest/docs/concepts/security/#policy-storage)
Istio stores **mesh-scope policies** in the root namespace. These policies have an empty selector apply to all workloads in the mesh. Policies that have a namespace scope are stored in the corresponding namespace. They only apply to workloads within their namespace. If you configure a `selector` field, the authentication policy only applies to workloads matching the conditions you configured.

Peer and request authentication policies are stored separately by kind, `PeerAuthentication` and `RequestAuthentication` respectively.

#### [Selector field](https://istio.io/latest/docs/concepts/security/#selector-field)
Peer and request authentication policies use `selector` fields to specify the label of the workloads to which the **policy applies.** The following example shows the selector field of a policy that applies to workloads with the `app:product-page` label:

```yaml
selector:
  matchLabels:
    app: product-page
```

If you don’t provide a value for the `selector` field, Istio matches the policy to all workloads in the storage scope of the policy. Thus, the `selector` fields help you specify the scope of the policies:

- Mesh-wide policy: A policy specified for the root namespace without or with an empty `selector` field.
- Namespace-wide policy: A policy specified for a non-root namespace without or with an empty `selector` field.
- Workload-specific policy: a policy defined in the regular namespace, with non-empty selector field.

Peer and request authentication policies follow the same hierarchy principles for the `selector` fields, but Istio combines and applies them in slightly different ways

#### [Peer authentication](https://istio.io/latest/docs/concepts/security/#peer-authentication)
Peer authentication policies specify the **mutual TLS mode** Istio enforces on target workloads. The following modes are supported:

- **PERMISSIVE**: Workloads accept both mutual TLS and plain text traffic. This mode is most useful during migrations when workloads without sidecar cannot use mutual TLS. Once workloads are migrated with sidecar injection, you should switch the mode to STRICT.
- **STRICT**: Workloads only accept mutual TLS traffic.
- **DISABLE**: Mutual TLS is disabled. From a security perspective, you shouldn’t use this mode unless you provide your own security solution.

When the mode is unset, the mode of the parent scope is inherited. Mesh-wide peer authentication policies with an unset mode use the `PERMISSIVE` mode by default.
The following peer authentication policy requires all workloads in namespace `foo` to use mutual TLS:

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: "example-policy"
  namespace: "foo"
spec:
  mtls:
    mode: STRICT
```